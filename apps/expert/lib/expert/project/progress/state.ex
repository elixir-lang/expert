defmodule Expert.Project.Progress.State do
  alias Expert.Configuration
  alias Expert.Protocol.Id
  alias Forge.Project
  alias GenLSP.Requests
  alias GenLSP.Structures

  require Logger

  defstruct project: nil, active: MapSet.new(), refs: %{}

  defguardp is_token(token) when is_binary(token) or is_integer(token)

  def new(%Project{} = project), do: %__MODULE__{project: project}

  @doc """
  Registers a client-initiated progress token with an optional `:ref`, which can be
  used as a stable identifier to report and end progress.
  """
  def register(%__MODULE__{} = state, token, opts \\ []) do
    opts = Keyword.validate!(opts, [:ref])

    active = MapSet.put(state.active, token)
    state = %{state | active: active}

    case Keyword.get(opts, :ref) do
      nil ->
        {:ok, state}

      ref when is_atom(ref) ->
        refs = Map.put(state.refs, ref, token)
        {:ok, %{state | refs: refs}}
    end
  end

  @doc """
  Begins server-initiated progress.

  Generates a token, requests the client create the progress indicator,
  and sends the begin notification.
  """
  def begin(%__MODULE__{} = state, title, opts) do
    lsp = Expert.get_lsp()
    token = System.unique_integer([:positive])

    case request_work_done_progress(lsp, token) do
      :ok ->
        notify_begin(lsp, token, title, opts)
        active = MapSet.put(state.active, token)
        {:ok, token, %{state | active: active}}

      {:error, reason} ->
        Logger.warning("Client rejected progress token: #{inspect(reason)}")
        {:error, :rejected}
    end
  end

  @doc """
  Registers an engine-initiated progress token.

  The token is generated by the engine and passed here. Requests the client
  create the progress indicator, sends the begin notification, and adds to active.

  If opts contains `:ref`, also registers a ref → token mapping so the engine
  can use `report_to_ref` and `complete_ref` without tracking the token.
  """
  def register_engine_token(%__MODULE__{} = state, token, title, opts) when is_token(token) do
    lsp = Expert.get_lsp()

    case request_work_done_progress(lsp, token) do
      :ok ->
        notify_begin(lsp, token, title, opts)
        active = MapSet.put(state.active, token)
        state = %{state | active: active}

        # If opts contains :ref, register the ref → token mapping
        state =
          case Keyword.get(opts, :ref) do
            nil -> state
            ref when is_atom(ref) -> %{state | refs: Map.put(state.refs, ref, token)}
          end

        {:ok, state}

      {:error, reason} ->
        Logger.warning("Client rejected engine progress token: #{inspect(reason)}")
        {:error, :rejected}
    end
  end

  @doc """
  Reports progress to the client.

  Returns `{:ok, token, state}` on success, `{:noop, state}` if token/ref not found.
  """
  def report(%__MODULE__{} = state, token, updates) when is_token(token) do
    if MapSet.member?(state.active, token) do
      lsp = Expert.get_lsp()
      notify_report(lsp, token, updates)
      {:ok, token, state}
    else
      Logger.warning("Progress report for unknown token: #{inspect(token)}")
      {:noop, state}
    end
  end

  def report(%__MODULE__{} = state, ref, updates) when is_atom(ref) do
    case Map.fetch(state.refs, ref) do
      {:ok, token} -> report(state, token, updates)
      :error -> {:noop, state}
    end
  end

  @doc """
  Completes a progress sequence by ref atom or token.
  """
  def complete(state, ref_or_token, opts)

  def complete(%__MODULE__{} = state, ref, opts) when is_atom(ref) do
    case Map.pop(state.refs, ref) do
      {token, refs} when is_token(token) -> complete(%{state | refs: refs}, token, opts)
      {nil, _} -> {:error, :unknown_ref}
    end
  end

  def complete(%__MODULE__{} = state, token, opts) when is_token(token) do
    if MapSet.member?(state.active, token) do
      lsp = Expert.get_lsp()
      notify_end(lsp, token, opts)
      active = MapSet.delete(state.active, token)
      {:ok, %{state | active: active}}
    else
      Logger.warning("Progress complete for unknown token: #{inspect(token)}")
      {:error, :unknown_token, state}
    end
  end

  defp notify_begin(lsp, token, title, opts) do
    if Configuration.client_supports?(:work_done_progress) do
      :ok =
        GenLSP.notify(lsp, %GenLSP.Notifications.DollarProgress{
          params: %Structures.ProgressParams{
            token: token,
            value: %Structures.WorkDoneProgressBegin{
              kind: "begin",
              title: title,
              message: Keyword.get(opts, :message),
              percentage: Keyword.get(opts, :percentage),
              cancellable: Keyword.get(opts, :cancellable)
            }
          }
        })
    end
  end

  defp notify_report(lsp, token, updates) do
    if Configuration.client_supports?(:work_done_progress) do
      :ok =
        GenLSP.notify(lsp, %GenLSP.Notifications.DollarProgress{
          params: %Structures.ProgressParams{
            token: token,
            value: %Structures.WorkDoneProgressReport{
              kind: "report",
              message: Keyword.get(updates, :message),
              percentage: Keyword.get(updates, :percentage)
            }
          }
        })
    end
  end

  defp notify_end(lsp, token, opts) do
    if Configuration.client_supports?(:work_done_progress) do
      :ok =
        GenLSP.notify(lsp, %GenLSP.Notifications.DollarProgress{
          params: %Structures.ProgressParams{
            token: token,
            value: %Structures.WorkDoneProgressEnd{
              kind: "end",
              message: Keyword.get(opts, :message)
            }
          }
        })
    end
  end

  defp request_work_done_progress(lsp, token) do
    if Configuration.client_supports?(:work_done_progress) do
      result =
        GenLSP.request(
          lsp,
          %Requests.WindowWorkDoneProgressCreate{
            id: Id.next(),
            params: %Structures.WorkDoneProgressCreateParams{token: token}
          }
        )

      case result do
        nil -> :ok
        error -> {:error, error}
      end
    else
      :ok
    end
  end
end
